---
layout: post
title: Антипаттерны разработки
description: Антипаттерны разработки
summary: Антипаттерны разработки
comments: true
tags: [anti-patterns&pitfalls]
---

Антипаттернов, которые относятся к разработке, на самом деле очень много. В этом посте я перечисляю некоторые общие антипаттерны, которые не зависят от конкретного языка программирования, описанные в одной [статье 2015 года](https://sahandsaba.com/nine-anti-patterns-every-programmer-should-be-aware-of-with-examples.html)

## 1. Premature optimization
aka **Преждевременная оптимизация**, **Корень всего зла**
Суть: преждевременная оптимизация до того, как вы накопили достаточно информации для принятия взвешенного решения о том, что и как следует оптимизировать.
Это плохо потому, что заранее бывает очень трудно угадать, где будут узкие и проблемные места на самом деле. Попытки оптимизации до того, как будет реальная информация скорее всего приведут к росту сложности кода и багам.

Избежать антипаттерна можно следующим образом: сфокусироваться на написании несложного и чистого кода (используя проверенные общепринятые практики), который будет работать. Затем уже, используя средства профилирования и другие средства, которые дают реальные результаты измерений, найти проблемные узкие участки кода. Полагаться нужно на конкретные результаты измерений, а не на догадки и предположения.

## 2. God class
**God class** - класс, который контролирует жизнь многих других классов, содержит множество зависимостей или нарушает принцип _Single Responsibility_ из SOLID. Это плохо, поскольку такие классы имеют тенденцию еще сильнее наращивать свою сложность. Это очень сложно сопровождать. Такие классы сложно дебажить, документировать и, зачастую, просто невозможно покрыть unit-тестами.

Как избежать: если такие классы уже есть - рефакторинг, а именно разделение на более мелкие и конкретные классы, покрытые unit-тестами, с меньшим кол-вом зависимостей и ответственности.

## 3. Fear of adding classes
Антипаттерн вытекает из предубеждения, что большое кол-во классов сделает проект более сложным и запутанным, которое выливается в страх добавления в проект новых классов и/или разбиение текущих больших классов на несколько более маленьких. Антипаттерн достаточно тесно связан с предыдущим, т.к. является одной из причин, по которой в проекте могут появляться God-классы.

Как избежать: в оригинале статьи написано, что можно просто перестать бояться и распутывать запутанный клубок нитей на отдельные нити. Мое личное мнение, что так-то оно, конечно, так, распутывать клубок в отдельные нити надо, но разрезать полученные нити на еще более короткие надо не всегда. Руководствоваться необходимо принципом Single Responsibility и здравым смыслом. Если посмотреть на нить и она логически полноценная и понятная, не является God-классом, нормально документируется, без проблем покрывается unit-тестами, то самое время остановиться.

## 4. Magic numbers and strings
Завязывание логики в коде на безымянных числах и строках, вместо использования именованных числовых/строковых констант. Проблема в том, что в данном случае нам неизвестно смысловое значение числа/строки. Это осложняет понимание и читаемость кода, и при необходимости изменения значения инструменты рефакторинга, поиска и замены могут добавить новых багов в работу приложения, заменив что-нибудь лишнее.
```csharp
    // Абстракный пример:
    var window = new Window(600, 600);
```
К счастью проявления данного антипаттерна легко можно заметить и исправить.

## 5. Inner-platform Effect
 Написание (воссоздание) функционала, уже доступного в используемом языке программирования или платформе. 
 
 Как избежать: изучайте возможности своего языка программирования, платформы и вообще инструментов, которыми пользуетесь. Не поддавайтесь искушению создавать конструкции, повторяющие уже существующие. Используйте инструменты по назначению. 
 
## 6. Useless (Poltergeist) Classes
Добавление в проект бесполезных классов, которые реально ни за что не отвечают; зачастую они просто вызывают методы других классов или просто добавляют _лишний слой абстракции_. Это плохо по причине, что такие классы увеличивают сложность, увеличивают объем кода и потребность покрытия тестами, делают код менее читаемым, т.к. разработчику сперва нужно понять, что этот бесполезный-класс делает.

Как избежать: избегайте классов, которые не отвечают ни за что или добаляют лишнюю абстракцию, не пишите их или отрефакторите код, чтобы избавиться от них. Помните, что простота и понятность кода вас никогда не подведет.