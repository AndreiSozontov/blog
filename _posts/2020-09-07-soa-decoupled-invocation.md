---
layout: post
title: SOA - Decoupled Invocation
description: SOA, сервисно-ориентированная архитектура, паттерны, микросервисы, Decoupled Invocation, брокеры сообщений, очереди, queue.
summary: SOA, сервисно-ориентированная архитектура, паттерны, микросервисы, Decoupled Invocation, брокеры сообщений, очереди, queue.
comments: true
tags: [architecture]
---

Основная причина использования описываемой техники: высоконагруженность системы. Кроме того, данная техника позволяет уменьшить прямую связанность между сервисами (если в операции участвует 2 или больше сервисов).
Проблема, когда в час-пик количество входящих запросов превышает скорость их обработки системой и не помогает апгрейд железа или горизонтальное масштабирование, является общей как для сервисных систем (SOA и микросервисы), так и для монолитных решений. И как следствие проблемы, во время таких пиковых нагрузок увеличивается время отклика системы (как минимум), либо она падает (худший вариант).

В качестве примера возьмем какую-нибудь вымышленную систему (например какой-то музыкальный сервис), но не всю, а лишь один из её сервисов, скажем сервис по продаже синглов (назовем SinglesService). Представим, что сервис написан качественно, он реализует модель _запрос-ответ_ (_request-reply_). Большинство времени сервис работает отлично и время ответа приемлимое. Вот только в дни, когда у одного или нескольких очень популярных артистов выходят ожидаемые синглы случаются пиковые нагрузки и все становится очень плохо.

Есть давно известное решение, подходящее всем системам (и SOA, и микросервисам), которое позволяет справляться с такими пиковыми нагрузками без проблем производительности и падений сервиса (у решения есть некоторая цена, но про нее чуть позже).
Решение заключается в разделении запроса и ответа, т.е. переходе от модели обмена сообщениями _request-reply_ к _request-reaction_, делая ответы сервиса как бы асинхронными. Т.к. в качестве ответа будет по сути новое сообщение, то запрос и ответ связываются между собой через какой-то уникальный **CorrelationId**, дабы потребитель мог их соотнести. В результате входящие запросы будут помещаться в очередь быстро (поскольку это недорогая операция) и сервис сможет принимать новые входящие запросы, не особо расходуя ресурсы.

## Классический способ
В SOA решение состояло из 3 базовых компонентов: _хендлера_ (handler), _очереди_ (queue) и _диспетчера_ (dispatcher), который выступал в качестве посредника (медиатора) между ними. Процесс организовывался следующим образом:

- Handler принимал входящий запросы и в качестве ответа давал подтверждение (ack), что запрос принят в обработку;
- Handler был ответственен за первоначальную обработку входящих сообщений, к которой может относиться трансформация или приоретизация (из сведений, содержащихся в самом сообщении), хотя данную первоначальную обработку следует делать минимальной, т.к. цель максимально по-быстрому положить сообщение в очередь и вернуть подтверждение;

Очередь (queue) должна хранить сообщения и позволять сервису-потребителю забирать их по его готовности. Очередь может быть как in-memory для скорости работы, так и может быть устойчивой (persistent) - сообщения, которые она хранит, не потеряются даже если сервер упадет. Для большей надежности будет хорошо, если очередь поддерживает транзакционность.

Диспетчер (dispatcher) занимается тем, что выделяет столько экземпляров по чтению и обработке сообщений из очереди, сколько нужно при текущей нагрузке, которая измеряется кол-вом сообщений, ожидающих своей очереди.

Все это прекрасно работает, если пиковые нагрузки бывают время от времени. Если же мы имеем дело с перманентной сверх-высокой нагрузкой, то SOA есть что предложить и в этом случае, однако описания данных стратегий будут в отдельных постах.

## Реализация
Что касается технологий, которые предоставят нам очереди, можно ориентироваться на брокеры сообщений, которые поддерживают persistence и транзакционность. Из актуальных (для .NET) и поддерживающих [протокол AMPQ](https://ru.wikipedia.org/wiki/AMQP) на момент написания поста: [RabbitMQ](https://www.rabbitmq.com/) и [NServiceBus](https://particular.net/nservicebus). MSMQ [уже умер](https://particular.net/blog/msmq-is-dead).

### Цена использования брокера сообщений

1. Несущественно, но увеличивается оверхед и задержки
2. Брокер сообщений нужно настроить и администрировать

Тот факт, что брокер сообщений является еще одной точкой отказа я сознательно не написал, потому что при его отсутствии во время пиковой нагрузки с гораздо большей вероятностью откажет перегруженный входящими запросами сервис.