---
layout: post
title: Делегаты. Как изменялся синтаксис
description: Делегаты. Изменение синтаксиса, анонимные методы, лямбда выражения. Action, Func, Predicate
summary: Делегаты. Изменение синтаксиса, анонимные методы, лямбда выражения. Action, Func, Predicate
comments: true
tags: [csharp]
---

В данном посте кратко разберем, что такое делегаты, зачем они нужны, как изначальный синтаксис изменялся с появлением анонимных методов и лямбда-выражений.

## Зачем нужны делегаты
Делегаты необходимы для того, чтобы "упаковать" какое-то поведение как бы в объект. Джон Скит приводит пример с посмертным завещанием - поведение (список методов, которые надо выполнить после смерти), которое "упаковывается в объект". Каждый экземпляр делегата содержит список вызова, т.е. список действий.
Класс `Thread` знает, что именно запускать в потоке, когда вы его стартуете, только потому, что вы предоставляете конструктору экземпляр делегата `ThreadStart` или `ParametrizedThreadStart`.
Без делегатов не появился бы LINQ, т.к. они там используются повсеместно.

Делегаты **immutable** (для потокобезопасности и защиты от внешних изменений).

## Элементарный пример
Для простого делегата необходимо выполнить следующие действия:
1. Объявить тип делегата (список входных аргументов и возвращаемый тип).
2. Написать в отдельном методе код, предназначенный для выполнения.
3. Создать экземпляр делегата.
4. Вызвать экземпляр делегата.

```charp
class Program
{
    // 1. Объявление типа делегата (список входных аргументов и возвращаемый тип).
    private delegate void Message();

    static void Main(string[] args)
    {
        // 3. Создание экземпляра делегата.
        Message msg = HelloWorld;

        // 4. Вызов экземпляра делегата.
        msg();
        Console.ReadKey();
    }

    // 2. Код, предназначенный для выполнения, должен содержаться внутри метода.
    private static void HelloWorld()
    {
        Console.WriteLine("Hello, World!");
    }
}
```

## Объединение делегатов
Экземпляры делегата могут объединяться друг с другом и удаляться друг из друга.

- `Delegate.Combine(x, y)` - явный вызов, встречается редко
- `x = x + y` и `x =+ y` операции, встречаются часто (синтаксический сахар, впоследствии распадается на `Delegate.Combine(x, y)`)

Удаление делегатов:
- `Delegate.Remove(source, value)` - явный вызов
- `-` и `-=`

## Проблемы и последующие улучшения

**Проблема 1** Синтаксис C# 1 довольно неуклюж: даже для простого действия приходится писать целый отдельный метод, чтобы создать для него экземпляр делегата.
**Решение** В C# 2 появились **анонимные методы** и упрощенный синтаксис.

```charp
class Program
{
    // 1. Объявление типа делегата (список входных аргументов и возвращаемый тип).
    private delegate void Message();

    static void Main(string[] args)
    {
        // 2. Создание экземпляра делегата c анонимным методом внутри.
        Message msg = delegate
        {
            Console.WriteLine("Hello, World!");
        };

        // 3. Вызов экземпляра делегата.
        msg();
        Console.ReadKey();
    }
}
```
В каких ситуациях используются анонимные методы? Когда нам надо определить однократное действие, которое не имеет много инструкций и нигде больше не используется. В частности, их можно использовать для обработки событий.


**Проблема 2** Синтаксис анонимных методов позволяет действию оставаться в точке создания, вместо того чтобы находиться в другом методе, который еще придется отыскать, чтобы понять, что в нем происходит, но он все-равно немного громоздкий.
**Решение**
В C# 3 появились **лямбда-выражения**, чтобы еще сильнее упростить синтаксис. Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые **можно передать в качестве параметров в другие методы**.

```charp
class Program
{
    // 1. Объявление типа делегата (список входных аргументов и возвращаемый тип).
    private delegate void Message();

    static void Main(string[] args)
    {
        // 2. Создание экземпляра делегата c лямбда-выражением.
        Message msg = () => Console.WriteLine("Hello, World!");

        // 3. Вызов экземпляра делегата.
        msg();
        Console.ReadKey();
    }
}
```

**Проблема 3** Все еще надо объявлять тип делегата, т.е. писать `private delegate void Message();`
**Решение**
Начиная с .NET Framework 3.5 это можно не делать, т.к. были добавлены добавлены:

**Action** - для void методов, которые не возвращают ничего. Могут иметь или не иметь входные параметры.
```charp
Action msg2 = () => Console.WriteLine("Hello, World2!");
Action<string> msg3 = (name) => Console.WriteLine($"Hello, {name}!");
```

**Func** - для не void методов. `Func<int x, int y, string result>` принимает на вход 2 int аргумента и в ответ возвращает string.
```charp
Func<int,int,string> func = (х, у) => (х * у).ToString();`
string result = func(2, 3);
```

**Predicate**
Делегат Predicate<T>, как правило, используется для сравнения, сопоставления некоторого объекта T определенному условию. В качестве выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено:
```charp
Predicate<int> isPositive = delegate (int x) { return x > 0; };
 
Console.WriteLine(isPositive(20)); // true
Console.WriteLine(isPositive(-20)); //false
```
В данном случае возвращается true или false в зависимости от того, больше нуля число или нет.
