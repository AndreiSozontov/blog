---
layout: post
title: SOA - Активный сервис и фоновые задания
description: SOA, сервисно-ориентированная архитектура, паттерны, микросервисы, active service, aктивный сервис, фоновые задания, background tasks.
summary: SOA, сервисно-ориентированная архитектура, микросервисы, active service, aктивный сервис, реализация, фоновые задания, background tasks.
comments: true
tags: [architecture]
---

Большинство сервисов , которые мы все пишем являются _пассивными_ по своей сути: сервис ничего не делает до тех пор, пока какой-либо из его методов не будет вызван извне (фронтендом, другим сервисом, либо напрямую через какой-то клиент). Только тогда внутри него ~~происходит какая-то магия~~ выполняется какая-то бизнес-логика и сервис возвращает ответ, в остальное же время сервис простаивает. Всё это более чем нормально, однако бывают такие ситуации, когда сервис следует сделать _активным_, а не пассивным.

Вообще, согласно идеологии SOA, сервисы следует делать как можно более _автономными_ и _самодостаточными_, потому что автономность уменьшает жесткую связанность между сервисами и улучшает гибкость всего решения в целом. Таким образом команды разработчиков могут работать каждая над своим сервисом и делать это независимо друг от друга, насколько это возможно. Отказоустойчивость сервиса также сильно связана с тем, насколько он автономен.

Возможна ситуация, когда ваш сервис зависит от одного или нескольких других сервисов, которые не всегда показывают стабильную работу, либо могут быть чувствительны к высоким нагрузкам из-за слишком частых запросов. Да, грамотное кэширование может улучшить ситуацию, но лишь частично. Даже если кэшированием можно снизить нагрузку на остальные сервисы, то обеспечить актуальность или можно даже сказать "свежесть" данных будет проблематично в некоторых случаях. Кроме того есть вариант, что вам все-равно понадобится делать повторяющиеся или единоразовые запросы, результаты которых нельзя и не нужно кэшировать. А иногда надо, чтобы сервис просто что-то делал сам в фоне. Тогда вам понадобится **активный сервис** (**active service**).

Сервис можно считать _активным_, если в нем есть как минимум один класс (или больше), который самостоятельно (по расписанию или через какой-то интервал времени) выполняет некоторую фоновую работу.

Возможные фоновые задания:
- Проактивные повторяющиеся запросы к внешним сервисам/системам для поддержания данных/состояния сервиса в актуальном состоянии (может работать в тандеме с кэшем или иным хранилищем состояния);
- Регулярное выполнение некоторой бизнес-логики (например, генерация отчетов);
- Регулярный мониторинг собственного состояния, либо состояния внешних сервисов (это получается сервис-**Watchdog**);
- Фоном обрабатывать запросы или выполнять некоторые интеграционные задачи;
- И все остальное, что угодно вашей фантазии и здравому смыслу при необходимости.

_Микросервисная архитектура_ переняла данный прием у SOA и встретить там активный сервис абсолютно нормально и естественно. Единственное, по терминологии там это называется просто _фоновые задания_ (_background tasks_) и чтобы это называли там active service я пока не встречал.

### Реализация
#### Реализация фоновых заданий
Благодаря .NET Core, а в частности **Microsoft.Extensions.Hosting**, реализация таких фоновых заданий очень сильно упрощается. В настоящее время нет никакой необходимости в самостоятельной написании функционала, который отдельным потоком будет что-то выполнять. 

Microsoft.Extensions.Hosting предоставляет нам интерфейс `IHostedService`:
```
public interface IHostedService
{
    Task StartAsync(CancellationToken cancellationToken);
    Task StopAsync(CancellationToken cancellationToken);
}
```
и абстрактный класс `BackgroundService`:
```
public abstract class BackgroundService : IHostedService, IDisposable
{
    protected BackgroundService();
    public virtual void Dispose();
    public virtual Task StartAsync(CancellationToken cancellationToken);
    public virtual Task StopAsync(CancellationToken cancellationToken);
    protected abstract Task ExecuteAsync(CancellationToken stoppingToken);
}
```
Всё, что нужно сделать - это отнаследоваться от `BackgroundService` и написать реализацию абстрактного метода `ExecuteAsync()`, например:
```
public class MyConcreteBackgroundService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            // Тут написать логику, которая будет выполняться.
            ...
            await Task.Delay(1000, stoppingToken);
        }

        await Task.CompletedTask;
    }
}
```
1000 мс указаны в качестве примера, интервал лучше вынести куда-то в конфигурацию и брать оттуда.

Да, и в Startup.cs зарегистрировать его:
```
    ...
    services.AddHostedService<MyConcreteBackgroundService>();
    ...
```

Более подробно про реализацию фоновых заданий можно почитать на docs.microsoft.com в статье [Background tasks with hosted services in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio). В популярном демонстрационном решении **eshopOnContainers** пример реализации активного сервиса/фонового задания можно найти в сервисе _Ordering_ в проекте _Ordering.BackgroundTasks_.

#### Реализация Watchdog-сервиса
Опять же, как быстро и легко в наши дни можно написать сервис по мониторингу себя и других сервисов. В .NET Core есть механизм health-check'ов и даже готовый UI для отображения результатов (**AspNetCore.Diagnostics.HealthChecks** и **AspNetCore.HealthChecks.UI**). По факту, Watchdog-сервис будет просто периодически дергать /hc адреса сервисов, которые он мониторит. Все, что требуется - это сконфигурировать HealthChecks-UI. Я дублировать информацию о конфигурации сюда не буду, её можно подробнее почитать на docs.microsoft.com на странице [Health monitoring](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/monitor-app-health#use-watchdogs), а так же на github у проекта [AspNetCore.Diagnostics.HealthChecks](https://github.com/xabaril/AspNetCore.Diagnostics.HealthChecks).